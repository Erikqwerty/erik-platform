// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/erikqwerty/erik-platform/clients/kafka.Consumer -o consumer_minimock.go -n ConsumerMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/erikqwerty/erik-platform/clients/kafka/consumer"
	"github.com/gojuno/minimock/v3"
)

// ConsumerMock implements mm_kafka.Consumer
type ConsumerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClose          func() (err error)
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mConsumerMockClose

	funcConsume          func(ctx context.Context, topicName string, handler consumer.Handler) (err error)
	funcConsumeOrigin    string
	inspectFuncConsume   func(ctx context.Context, topicName string, handler consumer.Handler)
	afterConsumeCounter  uint64
	beforeConsumeCounter uint64
	ConsumeMock          mConsumerMockConsume
}

// NewConsumerMock returns a mock for mm_kafka.Consumer
func NewConsumerMock(t minimock.Tester) *ConsumerMock {
	m := &ConsumerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mConsumerMockClose{mock: m}

	m.ConsumeMock = mConsumerMockConsume{mock: m}
	m.ConsumeMock.callArgs = []*ConsumerMockConsumeParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mConsumerMockClose struct {
	optional           bool
	mock               *ConsumerMock
	defaultExpectation *ConsumerMockCloseExpectation
	expectations       []*ConsumerMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConsumerMockCloseExpectation specifies expectation struct of the Consumer.Close
type ConsumerMockCloseExpectation struct {
	mock *ConsumerMock

	results      *ConsumerMockCloseResults
	returnOrigin string
	Counter      uint64
}

// ConsumerMockCloseResults contains results of the Consumer.Close
type ConsumerMockCloseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mConsumerMockClose) Optional() *mConsumerMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for Consumer.Close
func (mmClose *mConsumerMockClose) Expect() *mConsumerMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ConsumerMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ConsumerMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Consumer.Close
func (mmClose *mConsumerMockClose) Inspect(f func()) *mConsumerMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for ConsumerMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Consumer.Close
func (mmClose *mConsumerMockClose) Return(err error) *ConsumerMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ConsumerMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ConsumerMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &ConsumerMockCloseResults{err}
	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the Consumer.Close method
func (mmClose *mConsumerMockClose) Set(f func() (err error)) *ConsumerMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Consumer.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Consumer.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times Consumer.Close should be invoked
func (mmClose *mConsumerMockClose) Times(n uint64) *mConsumerMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of ConsumerMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mConsumerMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements mm_kafka.Consumer
func (mmClose *ConsumerMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the ConsumerMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to ConsumerMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished ConsumerMock.Close invocations
func (mmClose *ConsumerMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of ConsumerMock.Close invocations
func (mmClose *ConsumerMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *ConsumerMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *ConsumerMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConsumerMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to ConsumerMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to ConsumerMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to ConsumerMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mConsumerMockConsume struct {
	optional           bool
	mock               *ConsumerMock
	defaultExpectation *ConsumerMockConsumeExpectation
	expectations       []*ConsumerMockConsumeExpectation

	callArgs []*ConsumerMockConsumeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConsumerMockConsumeExpectation specifies expectation struct of the Consumer.Consume
type ConsumerMockConsumeExpectation struct {
	mock               *ConsumerMock
	params             *ConsumerMockConsumeParams
	paramPtrs          *ConsumerMockConsumeParamPtrs
	expectationOrigins ConsumerMockConsumeExpectationOrigins
	results            *ConsumerMockConsumeResults
	returnOrigin       string
	Counter            uint64
}

// ConsumerMockConsumeParams contains parameters of the Consumer.Consume
type ConsumerMockConsumeParams struct {
	ctx       context.Context
	topicName string
	handler   consumer.Handler
}

// ConsumerMockConsumeParamPtrs contains pointers to parameters of the Consumer.Consume
type ConsumerMockConsumeParamPtrs struct {
	ctx       *context.Context
	topicName *string
	handler   *consumer.Handler
}

// ConsumerMockConsumeResults contains results of the Consumer.Consume
type ConsumerMockConsumeResults struct {
	err error
}

// ConsumerMockConsumeOrigins contains origins of expectations of the Consumer.Consume
type ConsumerMockConsumeExpectationOrigins struct {
	origin          string
	originCtx       string
	originTopicName string
	originHandler   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConsume *mConsumerMockConsume) Optional() *mConsumerMockConsume {
	mmConsume.optional = true
	return mmConsume
}

// Expect sets up expected params for Consumer.Consume
func (mmConsume *mConsumerMockConsume) Expect(ctx context.Context, topicName string, handler consumer.Handler) *mConsumerMockConsume {
	if mmConsume.mock.funcConsume != nil {
		mmConsume.mock.t.Fatalf("ConsumerMock.Consume mock is already set by Set")
	}

	if mmConsume.defaultExpectation == nil {
		mmConsume.defaultExpectation = &ConsumerMockConsumeExpectation{}
	}

	if mmConsume.defaultExpectation.paramPtrs != nil {
		mmConsume.mock.t.Fatalf("ConsumerMock.Consume mock is already set by ExpectParams functions")
	}

	mmConsume.defaultExpectation.params = &ConsumerMockConsumeParams{ctx, topicName, handler}
	mmConsume.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConsume.expectations {
		if minimock.Equal(e.params, mmConsume.defaultExpectation.params) {
			mmConsume.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConsume.defaultExpectation.params)
		}
	}

	return mmConsume
}

// ExpectCtxParam1 sets up expected param ctx for Consumer.Consume
func (mmConsume *mConsumerMockConsume) ExpectCtxParam1(ctx context.Context) *mConsumerMockConsume {
	if mmConsume.mock.funcConsume != nil {
		mmConsume.mock.t.Fatalf("ConsumerMock.Consume mock is already set by Set")
	}

	if mmConsume.defaultExpectation == nil {
		mmConsume.defaultExpectation = &ConsumerMockConsumeExpectation{}
	}

	if mmConsume.defaultExpectation.params != nil {
		mmConsume.mock.t.Fatalf("ConsumerMock.Consume mock is already set by Expect")
	}

	if mmConsume.defaultExpectation.paramPtrs == nil {
		mmConsume.defaultExpectation.paramPtrs = &ConsumerMockConsumeParamPtrs{}
	}
	mmConsume.defaultExpectation.paramPtrs.ctx = &ctx
	mmConsume.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConsume
}

// ExpectTopicNameParam2 sets up expected param topicName for Consumer.Consume
func (mmConsume *mConsumerMockConsume) ExpectTopicNameParam2(topicName string) *mConsumerMockConsume {
	if mmConsume.mock.funcConsume != nil {
		mmConsume.mock.t.Fatalf("ConsumerMock.Consume mock is already set by Set")
	}

	if mmConsume.defaultExpectation == nil {
		mmConsume.defaultExpectation = &ConsumerMockConsumeExpectation{}
	}

	if mmConsume.defaultExpectation.params != nil {
		mmConsume.mock.t.Fatalf("ConsumerMock.Consume mock is already set by Expect")
	}

	if mmConsume.defaultExpectation.paramPtrs == nil {
		mmConsume.defaultExpectation.paramPtrs = &ConsumerMockConsumeParamPtrs{}
	}
	mmConsume.defaultExpectation.paramPtrs.topicName = &topicName
	mmConsume.defaultExpectation.expectationOrigins.originTopicName = minimock.CallerInfo(1)

	return mmConsume
}

// ExpectHandlerParam3 sets up expected param handler for Consumer.Consume
func (mmConsume *mConsumerMockConsume) ExpectHandlerParam3(handler consumer.Handler) *mConsumerMockConsume {
	if mmConsume.mock.funcConsume != nil {
		mmConsume.mock.t.Fatalf("ConsumerMock.Consume mock is already set by Set")
	}

	if mmConsume.defaultExpectation == nil {
		mmConsume.defaultExpectation = &ConsumerMockConsumeExpectation{}
	}

	if mmConsume.defaultExpectation.params != nil {
		mmConsume.mock.t.Fatalf("ConsumerMock.Consume mock is already set by Expect")
	}

	if mmConsume.defaultExpectation.paramPtrs == nil {
		mmConsume.defaultExpectation.paramPtrs = &ConsumerMockConsumeParamPtrs{}
	}
	mmConsume.defaultExpectation.paramPtrs.handler = &handler
	mmConsume.defaultExpectation.expectationOrigins.originHandler = minimock.CallerInfo(1)

	return mmConsume
}

// Inspect accepts an inspector function that has same arguments as the Consumer.Consume
func (mmConsume *mConsumerMockConsume) Inspect(f func(ctx context.Context, topicName string, handler consumer.Handler)) *mConsumerMockConsume {
	if mmConsume.mock.inspectFuncConsume != nil {
		mmConsume.mock.t.Fatalf("Inspect function is already set for ConsumerMock.Consume")
	}

	mmConsume.mock.inspectFuncConsume = f

	return mmConsume
}

// Return sets up results that will be returned by Consumer.Consume
func (mmConsume *mConsumerMockConsume) Return(err error) *ConsumerMock {
	if mmConsume.mock.funcConsume != nil {
		mmConsume.mock.t.Fatalf("ConsumerMock.Consume mock is already set by Set")
	}

	if mmConsume.defaultExpectation == nil {
		mmConsume.defaultExpectation = &ConsumerMockConsumeExpectation{mock: mmConsume.mock}
	}
	mmConsume.defaultExpectation.results = &ConsumerMockConsumeResults{err}
	mmConsume.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConsume.mock
}

// Set uses given function f to mock the Consumer.Consume method
func (mmConsume *mConsumerMockConsume) Set(f func(ctx context.Context, topicName string, handler consumer.Handler) (err error)) *ConsumerMock {
	if mmConsume.defaultExpectation != nil {
		mmConsume.mock.t.Fatalf("Default expectation is already set for the Consumer.Consume method")
	}

	if len(mmConsume.expectations) > 0 {
		mmConsume.mock.t.Fatalf("Some expectations are already set for the Consumer.Consume method")
	}

	mmConsume.mock.funcConsume = f
	mmConsume.mock.funcConsumeOrigin = minimock.CallerInfo(1)
	return mmConsume.mock
}

// When sets expectation for the Consumer.Consume which will trigger the result defined by the following
// Then helper
func (mmConsume *mConsumerMockConsume) When(ctx context.Context, topicName string, handler consumer.Handler) *ConsumerMockConsumeExpectation {
	if mmConsume.mock.funcConsume != nil {
		mmConsume.mock.t.Fatalf("ConsumerMock.Consume mock is already set by Set")
	}

	expectation := &ConsumerMockConsumeExpectation{
		mock:               mmConsume.mock,
		params:             &ConsumerMockConsumeParams{ctx, topicName, handler},
		expectationOrigins: ConsumerMockConsumeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConsume.expectations = append(mmConsume.expectations, expectation)
	return expectation
}

// Then sets up Consumer.Consume return parameters for the expectation previously defined by the When method
func (e *ConsumerMockConsumeExpectation) Then(err error) *ConsumerMock {
	e.results = &ConsumerMockConsumeResults{err}
	return e.mock
}

// Times sets number of times Consumer.Consume should be invoked
func (mmConsume *mConsumerMockConsume) Times(n uint64) *mConsumerMockConsume {
	if n == 0 {
		mmConsume.mock.t.Fatalf("Times of ConsumerMock.Consume mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConsume.expectedInvocations, n)
	mmConsume.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConsume
}

func (mmConsume *mConsumerMockConsume) invocationsDone() bool {
	if len(mmConsume.expectations) == 0 && mmConsume.defaultExpectation == nil && mmConsume.mock.funcConsume == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConsume.mock.afterConsumeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConsume.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Consume implements mm_kafka.Consumer
func (mmConsume *ConsumerMock) Consume(ctx context.Context, topicName string, handler consumer.Handler) (err error) {
	mm_atomic.AddUint64(&mmConsume.beforeConsumeCounter, 1)
	defer mm_atomic.AddUint64(&mmConsume.afterConsumeCounter, 1)

	mmConsume.t.Helper()

	if mmConsume.inspectFuncConsume != nil {
		mmConsume.inspectFuncConsume(ctx, topicName, handler)
	}

	mm_params := ConsumerMockConsumeParams{ctx, topicName, handler}

	// Record call args
	mmConsume.ConsumeMock.mutex.Lock()
	mmConsume.ConsumeMock.callArgs = append(mmConsume.ConsumeMock.callArgs, &mm_params)
	mmConsume.ConsumeMock.mutex.Unlock()

	for _, e := range mmConsume.ConsumeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmConsume.ConsumeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConsume.ConsumeMock.defaultExpectation.Counter, 1)
		mm_want := mmConsume.ConsumeMock.defaultExpectation.params
		mm_want_ptrs := mmConsume.ConsumeMock.defaultExpectation.paramPtrs

		mm_got := ConsumerMockConsumeParams{ctx, topicName, handler}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConsume.t.Errorf("ConsumerMock.Consume got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConsume.ConsumeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.topicName != nil && !minimock.Equal(*mm_want_ptrs.topicName, mm_got.topicName) {
				mmConsume.t.Errorf("ConsumerMock.Consume got unexpected parameter topicName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConsume.ConsumeMock.defaultExpectation.expectationOrigins.originTopicName, *mm_want_ptrs.topicName, mm_got.topicName, minimock.Diff(*mm_want_ptrs.topicName, mm_got.topicName))
			}

			if mm_want_ptrs.handler != nil && !minimock.Equal(*mm_want_ptrs.handler, mm_got.handler) {
				mmConsume.t.Errorf("ConsumerMock.Consume got unexpected parameter handler, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConsume.ConsumeMock.defaultExpectation.expectationOrigins.originHandler, *mm_want_ptrs.handler, mm_got.handler, minimock.Diff(*mm_want_ptrs.handler, mm_got.handler))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConsume.t.Errorf("ConsumerMock.Consume got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConsume.ConsumeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConsume.ConsumeMock.defaultExpectation.results
		if mm_results == nil {
			mmConsume.t.Fatal("No results are set for the ConsumerMock.Consume")
		}
		return (*mm_results).err
	}
	if mmConsume.funcConsume != nil {
		return mmConsume.funcConsume(ctx, topicName, handler)
	}
	mmConsume.t.Fatalf("Unexpected call to ConsumerMock.Consume. %v %v %v", ctx, topicName, handler)
	return
}

// ConsumeAfterCounter returns a count of finished ConsumerMock.Consume invocations
func (mmConsume *ConsumerMock) ConsumeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConsume.afterConsumeCounter)
}

// ConsumeBeforeCounter returns a count of ConsumerMock.Consume invocations
func (mmConsume *ConsumerMock) ConsumeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConsume.beforeConsumeCounter)
}

// Calls returns a list of arguments used in each call to ConsumerMock.Consume.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConsume *mConsumerMockConsume) Calls() []*ConsumerMockConsumeParams {
	mmConsume.mutex.RLock()

	argCopy := make([]*ConsumerMockConsumeParams, len(mmConsume.callArgs))
	copy(argCopy, mmConsume.callArgs)

	mmConsume.mutex.RUnlock()

	return argCopy
}

// MinimockConsumeDone returns true if the count of the Consume invocations corresponds
// the number of defined expectations
func (m *ConsumerMock) MinimockConsumeDone() bool {
	if m.ConsumeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConsumeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConsumeMock.invocationsDone()
}

// MinimockConsumeInspect logs each unmet expectation
func (m *ConsumerMock) MinimockConsumeInspect() {
	for _, e := range m.ConsumeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConsumerMock.Consume at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConsumeCounter := mm_atomic.LoadUint64(&m.afterConsumeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConsumeMock.defaultExpectation != nil && afterConsumeCounter < 1 {
		if m.ConsumeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConsumerMock.Consume at\n%s", m.ConsumeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConsumerMock.Consume at\n%s with params: %#v", m.ConsumeMock.defaultExpectation.expectationOrigins.origin, *m.ConsumeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConsume != nil && afterConsumeCounter < 1 {
		m.t.Errorf("Expected call to ConsumerMock.Consume at\n%s", m.funcConsumeOrigin)
	}

	if !m.ConsumeMock.invocationsDone() && afterConsumeCounter > 0 {
		m.t.Errorf("Expected %d calls to ConsumerMock.Consume at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConsumeMock.expectedInvocations), m.ConsumeMock.expectedInvocationsOrigin, afterConsumeCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConsumerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCloseInspect()

			m.MinimockConsumeInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConsumerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ConsumerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockConsumeDone()
}
